---
layout: post
title: Java 垃圾回收机制
category: 编程语言
tags: Java
keywords: Java
description: Java 垃圾回收机制
---

### 分代回收的思想

在Java中，我们必须了解不同对象的生命周期是不同的的事实。为了更好的回收垃圾，基本上所有的jvm都采用了按代的垃圾回收机制。

分代回收的最基本做法，就是将内存中的区域划分为3个不同的部分：年轻代，年老代，永久代(持久代)。

- 年轻代 :一个Eden区，两个Survivor区，三个区默认占用年轻代内存比例（8:1:1），存放在该区的对象生命周期很短。

    * Eden（伊甸区）:绝大多数创建的对象，都存放在该区

    * S0（From）：Eden区经过一轮"Young GC"("Minor GC")后，还存活的对象存放到S0区，并清空Eden区

    * S1（To）：当S1区堆积满对象时，将还存活的对象移动到S1区，并清空S0区，这时候，S1区就变成S0了。

- 年老代：年轻代中，经过几轮Young GC后，将还存活的对象移动到年老代。一般情况下，年老代的控件比年轻代大，存放的对象更多，当年老代内存不足的时候，会执行Full GC。如果对象很大（比如长字符串，大数组等），年轻代空间不足，对象会直接存放到年老代中。

- 永久代：存放JVM需要的应用元数据（在应用里使用的类和方法等），常量等。
> 注意，在jdk1.6后，永久代被取消了。


### 什么时候需要执行GC

#### Young GC(只针对年轻代的)

- 当新对象生成，并且在Eden区申请空间失败时
- 把尚且存活的对象移动到Servivor区，然后整理Survivor的两个区时
- 每次执行Full GC，都会触发Young GC

#### Full GC(针对整个堆)
     
- System.gc(),Runtime.getRuntime().gc(),heap dump
- 向年老代/永久代申请空间，但空间不足时

### 如何执行GC

- 年轻代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用**复制算法**，只需要付出少量存活对象的复制成本就可以完成收集。

- 年老代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用**"标记—清理"或者"标记—整理"**算法来进行回收。

 

